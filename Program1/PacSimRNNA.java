import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.*;
import pacsim.BFSPath;
import pacsim.PacAction;
import pacsim.PacCell;
import pacsim.PacFace;
import pacsim.PacSim;
import pacsim.PacUtils;
import pacsim.PacmanCell;

/** 
 *  John Lynch 
 *  CAP 4630
 *  Glinos
 *  Progam 1
 */

public class PacSimRNNA implements PacAction {
   
   private List<Point> path; // path to next node
   private int simTime;
   private ArrayList<RNNAPath> rnnaPaths; // Ordered list of nodes generated by the RNNA algorithm.

	public PacSimRNNA (String fname) {
		PacSim sim = new PacSim(fname);
		sim.init(this);
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("\nTSP using Repititive Neareste Neighbor Algorithm by John Lynch:      ");
		System.out.println("\nMaze : " + args[0] + "\n");
		new PacSimRNNA( args[0] );
	}
	
	@Override
	public void init() {
		simTime = 0;
		path = new ArrayList<Point>();
	}
	
	@Override
	public PacFace action(Object state) {
		PacCell[][] grid = (PacCell[][]) state;
		PacmanCell pc = PacUtils.findPacman ( grid );
      List<Point> food = PacUtils.findFood(grid);

      if (rnnaPaths == null || rnnaPaths.isEmpty()){
         System.out.println("RNNA Path is empty");

         //Generate Cost table
         List<Point> dest = new ArrayList<Point>(food); //list of needed destinations.
         dest.add(0,pc.getLoc());
         int [][] costTable = new int [dest.size()][dest.size()];
         for (int i = 0; i < costTable.length; i++){
            for (int o = 0; o < costTable[i].length; o++){
               costTable[i][o] = BFSPath.getPath( grid, dest.get(i), dest.get(o) ).size();
            }
         }

         //Print our cost table
         System.out.println("Cost Table :");
         for (int i = 0; i < costTable.length; i++){
            for(int o = 0; o < costTable[i].length; o++){
               System.out.printf("%d ", costTable[i][o] );
            }
            System.out.println();
         }
         System.out.println();

         System.out.println("Food Array :");
         for (int i = 0; i < food.size(); i++){
            System.out.printf("%d : (%d,%d)\n", i, food.get(i).x, food.get(i).y);
         }
         System.out.println();

         // Begin developing our RNNA path for the first step
         // use List food to create a first step
         rnnaPaths = new ArrayList<RNNAPath>();
         for (int i = 1; i < dest.size(); i++) {
            rnnaPaths.add(new RNNAPath (dest.get(i), costTable, costTable[0][i], 0, dest.size()) );
         }
            
         int step = 1;
         Collections.sort(rnnaPaths);
         printPopulation(step);

         while ( step < PacUtils.numFood(grid) ) { // perform population steps until we've done enough steps for each food pellet.
         // Note to self: make sure you mark used pellets.
            //TODO: iterate through steps of creating an rnna path
            for (int i = 0; i < rnnaPaths.size(); i++) {
               List<Point> nearestFood = rnnaPaths.get(i).findNextNearestPellets();
               
            }
            step++;
         }


      }
      
      //make sure pacman is in the game.
      if ( pc == null ) return null;


      if ( path.isEmpty() ) {
         Point tgt = PacUtils.nearestFood ( pc.getLoc(), grid);
         path = BFSPath.getPath(grid, pc.getLoc(), tgt);
         
        /* System.out.println("Pac-Man is currently at : [ " + pc.getLoc().x + 
               " , " + pc.getLoc().y + " ] ");
         System.out.println("Setting new target : " + tgt.x + " , " + tgt.y + " ]");*/
      }
      
      // move the pacman.

      Point next = path.remove(0);
		PacFace face = PacUtils.direction( pc.getLoc(), next);
      // System.out.printf("%5d : From [%2d, %2d] go %s%n,", 
      //       ++simTime, pc.getLoc().x, pc.getLoc().y, face);
      return face;
      
   }

   public void printPopulation (int step){
      System.out.printf("Population at step: %d\n", step);
      for (int i = 0; i < rnnaPaths.size(); i++){
         System.out.printf( "%d : %s", i, rnnaPaths.get(i).toString() );
      }
      return;
   }

}

class RNNAPath implements Comparable<RNNAPath> {
   private List<Point> path;            // ordered list of food pellets
   private List<Integer> costBreakup;   // only used for toString, just used to show the costs between each pellet 
   private int totalCost = 0;           // total cost of the current path
   private int[][] costTable;
   private boolean[] usedIndex;

   public RNNAPath (Point pt, int[][] costTable, int cCost, int ind, int size) {
      this.path = new ArrayList<Point>(); 
      this.costTable = costTable;
      this.costBreakup = new ArrayList<Integer>(); 
      this.usedIndex = new boolean[size];
      addPointToPath(pt, cCost, ind );
   }

   // function to add path and it's cost to the current class
   public void addPointToPath (Point a, int cost, int index){
      this.path.add(a);
      this.costBreakup.add(cost);
      this.totalCost += cost;
      // this.lastPoint = a;
      this.usedIndex[index] = true; //since we've used this index row/col, mark it in array.
      // this.pointsLeft[index] = false; //remove point of pellet we're adding to the path.
      return;
   }

   /* function that will return a List of the nearest Pellets.
    * This runs a BFS scan that will stop once it finds a pellet,
    * and will gather all other pellets it can using the distance
    * it took to find the first pellet. We can safely assume that
    * it will find the nearest pellet through the maze.
   */
   public List<Point> findNextNearestPellets () { 
      List<Point> pellets = new ArrayList<Point>();
      System.out.println("Current pellet: " + path.get(path.size()-1).toString() );
      return pellets;
   }

   @Override
   public int compareTo( RNNAPath a ) {
      // *MAY NEED TO ADD A CHECK TO MAKE SURE THE PATHS ARE THE SAME LENGTH*
      if ( a.totalCost <  this.totalCost ) return 1;// if return 1 if this has higher cost
      if ( a.totalCost == this.totalCost) return 0;
      if ( a.totalCost >  this.totalCost ) return -1;// if return -1 if a has higher cost.
      return 0;
   }

   @Override
   public String toString(){
      String pts = "";
      for (int i = 0; i < path.size(); i++){
         pts += "[(" + path.get(i).x + "," + path.get(i).y + ")," + costBreakup.get(i) + "]\n";
      }
      return "cost=" + this.totalCost + " : " + pts;
   }
   
}



